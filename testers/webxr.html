@ -1,583 +0,0 @@
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AbxrLib WebXR Test Environment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Three.js for 3D graphics -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- WebXR Polyfill for broader compatibility -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js"></script>
  <!-- AbxrLib -->
  <script src="dist/abxrlib-for-webxr.js"></script>
  
  <script>
    // Authentication configuration variables
    const appId = '471fd6fd-f5d0-4096-bc0c-17100c1c4fa0';
    const orgId = '5304ef74-423f-4bd4-87d9-cba4f19c3bdb';
    const authSecret = 'vEwWpJs5K2Kib3XeWBhXgQnQr43XNJCSyb5QJoGCU5ec590hFyb63vBSx6dX6Clj';
    const restUrl = 'https://lib-backend.xrdm.app/v1/';

    // Helper function to create appConfig with specific REST URL
    const appConfigTemplate = '<?xml version="1.0" encoding="utf-8" ?><configuration><appSettings><add key="REST_URL" value="{{REST_URL}}"/></appSettings></configuration>';
    function createAppConfig(restUrl) {
        return appConfigTemplate.replace('{{REST_URL}}', restUrl);
    }
    
    // Initialize AbxrLib with variables
    Abxr_init(appId, orgId, authSecret, createAppConfig(restUrl));
    
    // Enable debug mode
    Abxr.setDebugMode(true);
    
    // WebXR Scene Variables
    let scene, camera, renderer, xrSession;
    let eventButton, logButton, eventText, logText, titleText;
    let controllers = [];
    let room, lighting;
    
    // Desktop Controls Variables
    let keys = {};
    let mouseX = 0, mouseY = 0;
    let isMouseLookEnabled = false;
    const moveSpeed = 0.05;
    const lookSpeed = 0.002;
    
    // Initialize WebXR Environment
    function initWebXR() {
        console.log('Initializing WebXR Environment...');
        
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101020);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 2); // Standing height
        
        // Create renderer with WebXR support
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Add lighting
        setupLighting();
        
        // Create room environment
        createRoom();
        
        // Create UI elements
        createXRUI();
        
        // Setup WebXR controllers
        setupControllers();
        
        // Setup desktop movement controls
        setupDesktopControls();
        
        // Start render loop
        renderer.setAnimationLoop(render);
        
        console.log('WebXR Environment initialized');
    }
    
    function setupLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Point lights for atmosphere
        const pointLight1 = new THREE.PointLight(0x5A58EB, 0.6, 10);
        pointLight1.position.set(-3, 3, -3);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0x05DA98, 0.4, 8);
        pointLight2.position.set(3, 2, 3);
        scene.add(pointLight2);
    }
    
    function createRoom() {
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x333333,
            transparent: true,
            opacity: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Walls (subtle)
        const wallGeometry = new THREE.PlaneGeometry(10, 5);
        const wallMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x1a1a2e,
            transparent: true,
            opacity: 0.3
        });
        
        // Back wall
        const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
        backWall.position.set(0, 2.5, -5);
        scene.add(backWall);
        
        // Grid helper for spatial reference
        const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x444444);
        gridHelper.material.transparent = true;
        gridHelper.material.opacity = 0.2;
        scene.add(gridHelper);
    }
    
    function createXRUI() {
        // Title Text
        titleText = createTextMesh('AbxrLib WebXR Test', 0.15, 0xffffff);
        titleText.position.set(0, 3, -2);
        scene.add(titleText);
        
        // Send Event Button
        eventButton = createButton('Send Event', 0x5A58EB, -1.5, 2, -2);
        eventButton.userData = { action: 'sendEvent' };
        scene.add(eventButton);
        
        // Send Log Button  
        logButton = createButton('Send Log', 0x05DA98, 1.5, 2, -2);
        logButton.userData = { action: 'sendLog' };
        scene.add(logButton);
        
        // Result text areas
        eventText = createTextMesh('Click button to send event', 0.08, 0xcccccc);
        eventText.position.set(-1.5, 1.4, -2);
        scene.add(eventText);
        
        logText = createTextMesh('Click button to send log', 0.08, 0xcccccc);
        logText.position.set(1.5, 1.4, -2);
        scene.add(logText);
        
        // Instructions
        const instructions = createTextMesh('VR: Use controllers | Desktop: WASD + mouse', 0.06, 0x888888);
        instructions.position.set(0, 0.8, -2);
        scene.add(instructions);
    }
    
    function createButton(text, color, x, y, z) {
        const group = new THREE.Group();
        
        // Button geometry
        const buttonGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.1);
        const buttonMaterial = new THREE.MeshLambertMaterial({ color: color });
        const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
        button.castShadow = true;
        button.receiveShadow = true;
        
        // Button text
        const textMesh = createTextMesh(text, 0.06, 0xffffff);
        textMesh.position.z = 0.06;
        
        group.add(button);
        group.add(textMesh);
        group.position.set(x, y, z);
        
        // Add hover effect
        group.userData.originalColor = color;
        group.userData.hoverColor = color * 1.2;
        
        return group;
    }
    
    function createTextMesh(text, size, color) {
        // Create canvas for text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 256;
        
        context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
        context.font = `${size * 400}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, canvas.width / 2, canvas.height / 2);
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture, 
            transparent: true,
            alphaTest: 0.1
        });
        
        const geometry = new THREE.PlaneGeometry(size * text.length * 0.6, size * 2);
        const mesh = new THREE.Mesh(geometry, material);
        
        return mesh;
    }
    
    function updateTextMesh(textMesh, newText, size, color) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024;
        canvas.height = 256;
        
        context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
        context.font = `${size * 400}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(newText, canvas.width / 2, canvas.height / 2);
        
        textMesh.material.map = new THREE.CanvasTexture(canvas);
        textMesh.material.needsUpdate = true;
    }
    
    function setupControllers() {
        // Setup VR controllers
        for (let i = 0; i < 2; i++) {
            const controller = renderer.xr.getController(i);
            controller.addEventListener('selectstart', onSelectStart);
            controller.addEventListener('selectend', onSelectEnd);
            scene.add(controller);
            controllers.push(controller);
            
            // Add controller model
            const controllerGrip = renderer.xr.getControllerGrip(i);
            scene.add(controllerGrip);
        }
        
        // Setup ray casting for interaction
        const raycaster = new THREE.Raycaster();
        const intersectObjects = [eventButton, logButton];
        
        window.addEventListener('click', (event) => {
            if (!renderer.xr.isPresenting) {
                // Mouse interaction for desktop testing
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(intersectObjects, true);
                
                if (intersects.length > 0) {
                    handleButtonClick(intersects[0].object.parent);
                }
            }
        });
    }
    
    function setupDesktopControls() {
        // Keyboard controls for WASD movement
        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;
        });
        
        document.addEventListener('keyup', (event) => {
            keys[event.code] = false;
        });
        
        // Mouse controls for looking around
        document.addEventListener('mousemove', (event) => {
            if (isMouseLookEnabled && !renderer.xr.isPresenting) {
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                mouseX += movementX * lookSpeed;
                mouseY += movementY * lookSpeed;
                
                // Clamp vertical rotation to prevent over-rotation
                mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
            }
        });
        
        // Click to enable mouse look (pointer lock)
        renderer.domElement.addEventListener('click', () => {
            if (!renderer.xr.isPresenting) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        // Handle pointer lock changes
        document.addEventListener('pointerlockchange', () => {
            isMouseLookEnabled = document.pointerLockElement === renderer.domElement;
        });
        
        // ESC to disable mouse look
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Escape' && document.pointerLockElement) {
                document.exitPointerLock();
            }
        });
        
        console.log('Desktop controls initialized - WASD to move, click and drag mouse to look');
    }
    
    function onSelectStart(event) {
        const controller = event.target;
        const raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();
        
        tempMatrix.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
        
        const intersects = raycaster.intersectObjects([eventButton, logButton], true);
        if (intersects.length > 0) {
            handleButtonClick(intersects[0].object.parent);
        }
    }
    
    function onSelectEnd(event) {
        // Handle select end if needed
    }
    
    function handleButtonClick(button) {
        if (button.userData.action === 'sendEvent') {
            sendEvent();
        } else if (button.userData.action === 'sendLog') {
            sendLog();
        }
        
        // Visual feedback
        const originalScale = button.scale.clone();
        button.scale.multiplyScalar(1.1);
        setTimeout(() => {
            button.scale.copy(originalScale);
        }, 150);
    }
    
    // Send Event function (adapted for XR)
    async function sendEvent() {
        console.log("Executing Abxr.Event() in XR");
        updateTextMesh(eventText, 'Sending event...', 0.08, 0xffaa00);
        
        try {
            if (typeof Abxr === 'undefined') {
                updateTextMesh(eventText, 'Error: Library not initialized', 0.08, 0xff4444);
                return;
            }
            
            const originalFetch = window.fetch;
            let responseData = undefined;
            
            window.fetch = async (...args) => {
                const response = await originalFetch(...args);
                const clone = response.clone();
                try {
                    const data = await clone.json();
                    responseData = data;
                } catch (e) {
                    responseData = { error: "Could not parse response as JSON" };
                }
                return response;
            };
            
            const result = await Abxr.Event('xr_user_action', { 
                action: 'button_click', 
                environment: 'webxr',
                timestamp: new Date().toISOString()
            });
            
            window.fetch = originalFetch;
            
            const statusText = `Event sent! Status: ${result}`;
            updateTextMesh(eventText, statusText, 0.08, 0x05DA98);
            
        } catch (error) {
            updateTextMesh(eventText, `Error: ${error.message}`, 0.08, 0xff4444);
        }
    }
    
    // Send Log function (adapted for XR)
    async function sendLog() {
        console.log("Executing Abxr.LogDebug() in XR");
        updateTextMesh(logText, 'Sending log...', 0.08, 0xffaa00);
        
        try {
            if (typeof Abxr === 'undefined') {
                updateTextMesh(logText, 'Error: Library not initialized', 0.08, 0xff4444);
                return;
            }
            
            const originalFetch = window.fetch;
            let responseData = undefined;
            
            window.fetch = async (...args) => {
                const response = await originalFetch(...args);
                const clone = response.clone();
                try {
                    const data = await clone.json();
                    responseData = data;
                } catch (e) {
                    responseData = { error: "Could not parse response as JSON" };
                }
                return response;
            };
            
            const result = await Abxr.LogDebug('XR User performed action in WebXR environment');
            
            window.fetch = originalFetch;
            
            const statusText = `Log sent! Status: ${result}`;
            updateTextMesh(logText, statusText, 0.08, 0x05DA98);
            
        } catch (error) {
            updateTextMesh(logText, `Error: ${error.message}`, 0.08, 0xff4444);
        }
    }
    
    function render() {
        // Handle desktop movement only when not in VR
        if (!renderer.xr.isPresenting) {
            handleDesktopMovement();
        }
        
        renderer.render(scene, camera);
    }
    
    function handleDesktopMovement() {
        // Apply mouse look rotation
        if (isMouseLookEnabled) {
            camera.rotation.y = -mouseX;
            camera.rotation.x = -mouseY;
            camera.rotation.order = 'YXZ'; // Prevent gimbal lock
        }
        
        // Handle WASD movement
        const direction = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        // Get camera direction vectors
        camera.getWorldDirection(direction);
        right.crossVectors(direction, camera.up).normalize();
        
        // Calculate movement based on pressed keys
        const moveVector = new THREE.Vector3();
        
        if (keys['KeyW']) {
            moveVector.add(direction.clone().multiplyScalar(moveSpeed));
        }
        if (keys['KeyS']) {
            moveVector.add(direction.clone().multiplyScalar(-moveSpeed));
        }
        if (keys['KeyA']) {
            moveVector.add(right.clone().multiplyScalar(-moveSpeed));
        }
        if (keys['KeyD']) {
            moveVector.add(right.clone().multiplyScalar(moveSpeed));
        }
        
        // Apply movement to camera position
        camera.position.add(moveVector);
        
        // Keep camera at reasonable height (optional - prevents going below floor)
        camera.position.y = Math.max(0.5, camera.position.y);
    }
    
    // Handle window resize
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Initialize everything when page loads
    window.addEventListener('load', () => {
        initWebXR();
        
        // Add VR button if WebXR is supported
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                if (supported) {
                    const vrButton = document.createElement('button');
                    vrButton.textContent = 'Enter VR';
                    vrButton.style.position = 'absolute';
                    vrButton.style.top = '20px';
                    vrButton.style.left = '20px';
                    vrButton.style.padding = '12px 24px';
                    vrButton.style.fontSize = '16px';
                    vrButton.style.background = '#5A58EB';
                    vrButton.style.color = 'white';
                    vrButton.style.border = 'none';
                    vrButton.style.borderRadius = '8px';
                    vrButton.style.cursor = 'pointer';
                    vrButton.style.zIndex = '1000';
                    
                    vrButton.addEventListener('click', () => {
                        if (!renderer.xr.isPresenting) {
                            navigator.xr.requestSession('immersive-vr').then((session) => {
                                renderer.xr.setSession(session);
                                xrSession = session;
                            });
                        } else {
                            xrSession.end();
                        }
                    });
                    
                    document.body.appendChild(vrButton);
                }
            });
        }
        
        window.addEventListener('resize', onWindowResize);
    });
  </script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    canvas {
      display: block;
    }
    
    #info {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      max-width: 300px;
      font-size: 14px;
      z-index: 1000;
    }
    
    #info h3 {
      margin: 0 0 10px 0;
      color: #5A58EB;
    }
    
    #info p {
      margin: 5px 0;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3>AbxrLib WebXR Test</h3>
    <p><strong>Desktop:</strong> Click buttons with mouse</p>
    <p><strong>Movement:</strong> WASD keys to move around</p>
    <p><strong>Look:</strong> Click canvas + move mouse to look</p>
    <p><strong>Exit Look:</strong> Press ESC key</p>
    <p><strong>VR:</strong> Point and click with controllers</p>
    <p><strong>Mobile:</strong> Touch the buttons</p>
  </div>
</body>
</html>